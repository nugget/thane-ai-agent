package memory

import (
	"log/slog"
	"sync"
	"time"
)

// ToolCallSource provides tool call records for archiving.
type ToolCallSource interface {
	GetToolCalls(conversationID string, limit int) []ToolCall
	ClearToolCalls(conversationID string) error
}

// sessionEntry caches an active session's ID and start time to avoid
// repeated database lookups on the per-turn hot path.
type sessionEntry struct {
	id        string
	startedAt time.Time
}

// ArchiveAdapter bridges the ArchiveStore to the agent.SessionArchiver interface.
// It manages session lifecycle and converts between memory and archive message types.
type ArchiveAdapter struct {
	store      *ArchiveStore
	logger     *slog.Logger
	toolSource ToolCallSource // optional — archives tool calls alongside messages

	// Track active sessions in memory for fast lookup
	mu       sync.RWMutex
	sessions map[string]sessionEntry // conversationID -> cached session
}

// NewArchiveAdapter creates an adapter that implements agent.SessionArchiver.
func NewArchiveAdapter(store *ArchiveStore, logger *slog.Logger) *ArchiveAdapter {
	return &ArchiveAdapter{
		store:    store,
		logger:   logger,
		sessions: make(map[string]sessionEntry),
	}
}

// SetToolCallSource configures a source for tool call records to archive.
func (a *ArchiveAdapter) SetToolCallSource(source ToolCallSource) {
	a.toolSource = source
}

// ArchiveConversation archives all messages from a conversation.
func (a *ArchiveAdapter) ArchiveConversation(conversationID string, messages []Message, reason string) error {
	sessionID := a.ActiveSessionID(conversationID)

	archived := make([]ArchivedMessage, len(messages))
	for i, m := range messages {
		archived[i] = ArchivedMessage{
			ConversationID: conversationID,
			SessionID:      sessionID,
			Role:           m.Role,
			Content:        m.Content,
			Timestamp:      m.Timestamp,
			TokenCount:     estimateTokens(m.Content),
			ToolCalls:      m.ToolCalls,
			ToolCallID:     m.ToolCallID,
			ArchiveReason:  reason,
		}
	}

	if err := a.store.ArchiveMessages(archived); err != nil {
		return err
	}

	// Archive associated tool calls if a source is configured
	toolCallCount := 0
	if a.toolSource != nil {
		calls := a.toolSource.GetToolCalls(conversationID, 10000)
		if len(calls) > 0 {
			archivedCalls := make([]ArchivedToolCall, len(calls))
			for i, tc := range calls {
				archivedCalls[i] = ArchivedToolCall{
					ID:             tc.ID,
					ConversationID: tc.ConversationID,
					SessionID:      sessionID,
					ToolName:       tc.ToolName,
					Arguments:      tc.Arguments,
					Result:         tc.Result,
					Error:          tc.Error,
					StartedAt:      tc.StartedAt,
					CompletedAt:    tc.CompletedAt,
					DurationMs:     tc.DurationMs,
				}
			}
			if err := a.store.ArchiveToolCalls(archivedCalls); err != nil {
				a.logger.Error("failed to archive tool calls", "error", err)
				// Don't fail the whole archive for tool calls
			} else {
				toolCallCount = len(archivedCalls)
				// Clear archived tool calls from the working store so they
				// aren't re-archived on the next session boundary (#271).
				if err := a.toolSource.ClearToolCalls(conversationID); err != nil {
					a.logger.Warn("failed to clear tool calls after archiving",
						"conversation", conversationID,
						"error", err,
					)
				}
			}
		}
	}

	a.logger.Info("conversation archived",
		"conversation", conversationID,
		"messages", len(messages),
		"tool_calls", toolCallCount,
		"reason", reason,
	)
	return nil
}

// StartSession begins a new session and returns its ID.
func (a *ArchiveAdapter) StartSession(conversationID string) (string, error) {
	sess, err := a.store.StartSession(conversationID)
	if err != nil {
		return "", err
	}

	a.mu.Lock()
	a.sessions[conversationID] = sessionEntry{id: sess.ID, startedAt: sess.StartedAt}
	a.mu.Unlock()

	a.logger.Info("session started",
		"session", ShortID(sess.ID),
		"conversation", conversationID,
	)
	return sess.ID, nil
}

// EndSession ends a session. Session metadata is generated by the
// background summarizer worker, not here — this avoids a race with
// process shutdown that previously caused summaries to be lost.
func (a *ArchiveAdapter) EndSession(sessionID string, reason string) error {
	if err := a.store.EndSession(sessionID, reason); err != nil {
		return err
	}

	// Remove from active cache
	a.mu.Lock()
	for conv, entry := range a.sessions {
		if entry.id == sessionID {
			delete(a.sessions, conv)
			break
		}
	}
	a.mu.Unlock()

	a.logger.Info("session ended",
		"session", ShortID(sessionID),
		"reason", reason,
	)
	return nil
}

// ActiveSessionID returns the current session ID for a conversation, or empty.
func (a *ArchiveAdapter) ActiveSessionID(conversationID string) string {
	a.mu.RLock()
	entry := a.sessions[conversationID]
	a.mu.RUnlock()

	if entry.id != "" {
		return entry.id
	}

	// Fall back to database lookup
	sess, err := a.store.ActiveSession(conversationID)
	if err != nil || sess == nil {
		return ""
	}

	// Cache it
	a.mu.Lock()
	a.sessions[conversationID] = sessionEntry{id: sess.ID, startedAt: sess.StartedAt}
	a.mu.Unlock()

	return sess.ID
}

// OnMessage tracks message count for the active session.
func (a *ArchiveAdapter) OnMessage(conversationID string) {
	sid := a.ActiveSessionID(conversationID)
	if sid == "" {
		return
	}
	// Best-effort — don't propagate errors for a counter
	_ = a.store.IncrementSessionCount(sid)
}

// EnsureSession starts a session if none is active for the conversation.
func (a *ArchiveAdapter) EnsureSession(conversationID string) string {
	if sid := a.ActiveSessionID(conversationID); sid != "" {
		return sid
	}

	sid, err := a.StartSession(conversationID)
	if err != nil {
		a.logger.Error("failed to start session", "error", err)
		return ""
	}
	return sid
}

// ActiveSessionStartedAt returns when the active session for a conversation
// began, or the zero time if there is no active session. Uses the in-memory
// cache populated by StartSession and ActiveSessionID to avoid per-turn
// database lookups.
func (a *ArchiveAdapter) ActiveSessionStartedAt(conversationID string) time.Time {
	a.mu.RLock()
	entry := a.sessions[conversationID]
	a.mu.RUnlock()

	if entry.id != "" {
		return entry.startedAt
	}

	// Fall back to database lookup and cache the result.
	sess, err := a.store.ActiveSession(conversationID)
	if err != nil || sess == nil {
		return time.Time{}
	}

	a.mu.Lock()
	a.sessions[conversationID] = sessionEntry{id: sess.ID, startedAt: sess.StartedAt}
	a.mu.Unlock()

	return sess.StartedAt
}

// Store returns the underlying ArchiveStore for direct access (API endpoints, etc.)
func (a *ArchiveAdapter) Store() *ArchiveStore {
	return a.store
}
